//
//  InspectorEngine.swift
//  ProcessTrustInspector
//
// High-level State Coordinator for the Process & Trust Inspector.
//
// Responsibilities:
// - Maintain the source-of-truth for the UI (Selected PID, Snapshot, Metadata)
// - Enumerate GUI applications (NSWorkspace) for the primary navigation list
// - Orchestrate data collection by delegating to specialized inspectors
//   (ProcessInspector, CodeSigningInspector)
// - Transform raw process data into a human-readable narrative
//
// Non-responsibilities:
// - No direct kernel/syscall logic (delegated to ProcessInspector)
// - No low-level code signing logic (delegated to CodeSigningInspector)
// - No security verdicts or risk assessments
//
// Design notes:
// - Acts as a "Controller" in the MVVM/Observable pattern
// - Failure-tolerant: If an inspection fails, the engine transitions to an
//   explanatory error state rather than crashing.


import Foundation
import Observation
import AppKit
import Darwin

@Observable
final class InspectorEngine {
    
    // MARK: - Published engine state (observed by Views)

    /// Point-in-time list of running GUI applications.
    /// Derived from NSWorkspace and refreshed manually.
    var runningAppList: [RunningAppRow] = []
    
    /// Snapshot for the currently selected PID, if inspection succeeds.
    /// Nil when selection fails or data is unavailable.
    var selectedSnapshot: ProcessSnapshot? = nil
    
    /// Human-readable explanation generated by the engine.
    /// This is the primary product of the tool.
    var selectionExplanationText: String = ""
    
    /// Currently selected PID (best-effort handle; may become stale).
    var selectedPID: pid_t = 0
    
    /// Diagnostic counters for UI/debug visibility.
    var runningAppCount: Int = 0
    var refreshCount: Int = 0
    
    // MARK: - Inspectors
    
    /// Inspectors for looking into data structures
    private let processInspector = ProcessInspector()
    
    /// Coordinates the inspection of a specific process.=
    /// This method acts as the primary bridge between the user's selection
    /// and the low-level inspection subsystem.
    ///
    /// Workflow:
    /// 1. Updates the tracking PID for the UI.
    /// 2. Delegates data collection to the ProcessInspector.
    /// 3. Updates the 'narrative' (explanation text) based on the result.
    ///
    /// - Parameter pid: The process identifier to inspect.
    func select(pid: pid_t) {
        
        self.selectedSnapshot = processInspector.getProcessSnapshot(from: pid)
        self.selectedPID = pid
        
        if let _ = self.selectedSnapshot {
            self.selectionExplanationText = """
                \u{2022} This is a best-effort identity snapshot for the selected process.
                \u{2022} PID identifies a running instance.
                \u{2022} Bundle ID only exists for bundled apps.
                \u{2022} Executable path tells you what binary is running and is the starting point for code-signing/trust checks.
                \u{2022} Missing fields are normal.
                """
        } else {
            self.selectionExplanationText = """
            \u{2022} PID no longer exists. Process has exited since list was last refreshed.
            """
        }
        
    }
    
    
    /// Refreshes the point-in-time list of running GUI applications.
    ///
    /// Scope limitation:
    /// - Uses NSWorkspace, so this only includes user-space GUI apps.
    /// - CLI tools and background processes are intentionally out of
    ///   scope at this stage.
    
    func refresh() {
        self.refreshCount += 1
        self.runningAppList = []
        
        let appList = NSWorkspace.shared.runningApplications
        
        for app in appList {
            
            let newApp = RunningAppRow(pPid: app.processIdentifier,
                                       pName: app.localizedName,
                                       pBI:app.bundleIdentifier)
            
            runningAppList.append(newApp)
        }
        self.runningAppCount = self.runningAppList.count
    }

    init() {
        refresh()
    }
}
