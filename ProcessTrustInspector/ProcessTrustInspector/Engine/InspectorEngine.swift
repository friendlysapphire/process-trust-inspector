//
//  InspectorEngine.swift
//  ProcessTrustInspector
//
// Central orchestration layer for the Process & Trust Inspector.
//
// Responsibilities:
// - Enumerate running GUI applications (via NSWorkspace)
// - Manage selection state for a target process
// - Produce a best-effort ProcessSnapshot for the selected PID
// - Generate plain-English explanation text describing what is known,
//   what is unknown, and why
//
// Non-responsibilities:
// - No UI logic or presentation decisions
// - No malware verdicts or safety claims
// - No assumption that missing data implies trust or risk
//
// Design notes:
// - All inspection is best-effort and non-fatal
// - Race conditions (process exit, PID reuse) are expected and handled
// - Static code identity is derived from on-disk binaries and does NOT
//   prove runtime behavior
//


import Foundation
import Observation
import AppKit
import Darwin

@Observable
final class InspectorEngine {
    
    // MARK: - Published engine state (observed by Views)

    /// Point-in-time list of running GUI applications.
    /// Derived from NSWorkspace and refreshed manually.
    var runningAppList: [RunningAppRow] = []
    
    /// Snapshot for the currently selected PID, if inspection succeeds.
    /// Nil when selection fails or data is unavailable.
    var selectedSnapshot: ProcessSnapshot? = nil
    
    /// Human-readable explanation generated by the engine.
    /// This is the primary product of the tool.
    var selectionExplanationText: String = ""
    
    /// Currently selected PID (best-effort handle; may become stale).
    var selectedPID: pid_t = 0
    
    /// Diagnostic counters for UI/debug visibility.
    var runningAppCount: Int = 0
    var refreshCount: Int = 0
    
    // MARK: - Inspectors
    
    /// Inspectors for looking into data structures
    private let signingInspector = CodeSigningInspector()
    
    /// Selects a running process by PID and attempts to build
    /// an identity snapshot.
    ///
    /// Selection is intentionally non-fatal:
    /// - The running-app list is point-in-time
    /// - Processes may exit between render and click
    /// - PIDs may be reused
    ///
    /// On failure, the engine clears the snapshot and explains
    /// why inspection could not be completed.
    
    func select(pid: pid_t) {
        
        // TODO (identity): Migrate from pid_t to audit_token_t to ensure we aren't inspecting a recycled PID
        // TODO (scope):  use proc_pidpath (libproc.h) to capture non-GUI apps if necesaery
        
        let appList = NSWorkspace.shared.runningApplications
        
        guard let targetApp = appList.first(where: { $0.processIdentifier == pid }) else {
            // Normal race condition: process exited or list changed
            // between enumeration and selection.
            
            self.selectedSnapshot = nil
            self.selectionExplanationText = """
                \u{2022} PID no longer exists. Process has exited since list was last refreshed.
                """
            self.selectedPID = pid
            
            return
        }
        
        self.selectedPID = pid
        let path = targetApp.executableURL
        let signingInfo: SigningSummary?
        
        if let path {
            signingInfo = self.signingInspector.getSigningSummary(path: path)
        } else {
            signingInfo = nil
        }
        
       // get the running user ID and parent PID from proc_pidinfo in the bowels of the os
        
        //int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
        var parentPid: pid_t? = nil
        var processUid: pid_t = 0
        var parentApp: NSRunningApplication? = nil
        var parentAppName: String? = nil
        var bsdinfo = proc_bsdinfo()
        let bsdinfo_size = MemoryLayout<proc_bsdinfo>.size
        var got_ppid: Int32 = 0
        
        withUnsafeMutablePointer(to: &bsdinfo) { ptr in
            got_ppid = proc_pidinfo(Int32(pid),PROC_PIDTBSDINFO,0,ptr,Int32(bsdinfo_size))
            if got_ppid == bsdinfo_size {
                parentPid = pid_t(bitPattern: ptr.pointee.pbi_ppid)
                processUid = pid_t(bitPattern: ptr.pointee.pbi_uid)
            }
        }
        
        // if there's a parent PID, get the associated process name
        if let parentPid {
            parentApp = appList.first(where: { $0.processIdentifier == parentPid })
            if let parentApp {
                parentAppName = parentApp.localizedName
            }
        
        }
        
        // TODO: figure out if there's potential inconsistency/incompleteness between
        // appList coming from NSWorkspace.shared.runningApplications and lower level info coming from
        // proc_pidinfo
        
        self.selectedSnapshot = ProcessSnapshot(pPid: pid,
                                                pUid: processUid,
                                                pParentPid: parentPid,
                                                pParentPidName: parentAppName,
                                                pName: targetApp.localizedName,
                                                pStartTime: targetApp.launchDate,
                                                pBundleIdentifier: targetApp.bundleIdentifier,
                                                pExecutablePath: path,
                                                pSigningSummary: signingInfo)
                
        self.selectionExplanationText = """
            \u{2022} This is a best-effort identity snapshot for the selected process.
            \u{2022} PID identifies a running instance.
            \u{2022} Bundle ID only exists for bundled apps.
            \u{2022} Executable path tells you what binary is running and is the starting point for code-signing/trust checks.
            \u{2022} Missing fields are normal.
            """
    }
    
    
    /// Refreshes the point-in-time list of running GUI applications.
    ///
    /// Scope limitation:
    /// - Uses NSWorkspace, so this only includes user-space GUI apps.
    /// - CLI tools and background processes are intentionally out of
    ///   scope at this stage.
    
    func refresh() {
        self.refreshCount += 1
        self.runningAppList = []
        
        let appList = NSWorkspace.shared.runningApplications
        
        for app in appList {
            
            let newApp = RunningAppRow(pPid: app.processIdentifier,
                                       pName: app.localizedName,
                                       pBI:app.bundleIdentifier)
            
            runningAppList.append(newApp)
        }
        self.runningAppCount = self.runningAppList.count
    }

    init() {
        refresh()
    }
}
